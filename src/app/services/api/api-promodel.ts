//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccesoClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: SolicitudAcceso | undefined): Observable<RespuestaLogin>;
    /**
     * @param body (optional) 
     * @return Success
     */
    passwordPost(body: string | undefined): Observable<Respuesta>;
    /**
     * @param body (optional) 
     * @return Success
     */
    id(id: string, body: string | undefined): Observable<void>;
    /**
     * @return Success
     */
    passwordGet(id: string): Observable<SolicitudSoporteUsuario>;
    /**
     * @return Success
     */
    tokenRefresh(token: string): Observable<RespuestaLogin>;
    /**
     * @param body (optional) 
     * @return Success
     */
    establecer(body: EstablecerContrasena | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class AccesoClient implements IAccesoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: SolicitudAcceso | undefined, httpContext?: HttpContext): Observable<RespuestaLogin> {
        let url_ = this.baseUrl + "/acceso/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RespuestaLogin>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RespuestaLogin>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<RespuestaLogin> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RespuestaLogin;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RespuestaLogin>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    passwordPost(body: string | undefined, httpContext?: HttpContext): Observable<Respuesta> {
        let url_ = this.baseUrl + "/acceso/password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPasswordPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPasswordPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Respuesta>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Respuesta>;
        }));
    }

    protected processPasswordPost(response: HttpResponseBase): Observable<Respuesta> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Respuesta;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Respuesta>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    id(id: string, body: string | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/acceso/password/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    passwordGet(id: string, httpContext?: HttpContext): Observable<SolicitudSoporteUsuario> {
        let url_ = this.baseUrl + "/acceso/password/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPasswordGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPasswordGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SolicitudSoporteUsuario>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SolicitudSoporteUsuario>;
        }));
    }

    protected processPasswordGet(response: HttpResponseBase): Observable<SolicitudSoporteUsuario> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SolicitudSoporteUsuario;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SolicitudSoporteUsuario>(null as any);
    }

    /**
     * @return Success
     */
    tokenRefresh(token: string, httpContext?: HttpContext): Observable<RespuestaLogin> {
        let url_ = this.baseUrl + "/acceso/token-refresh/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTokenRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTokenRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RespuestaLogin>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RespuestaLogin>;
        }));
    }

    protected processTokenRefresh(response: HttpResponseBase): Observable<RespuestaLogin> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RespuestaLogin;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RespuestaLogin>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    establecer(body: EstablecerContrasena | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/acceso/password/establecer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEstablecer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEstablecer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEstablecer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface ICastingClient {
    /**
     * @param inactivos (optional) 
     * @return Success
     */
    castingGet(inactivos: boolean | undefined): Observable<CastingListElement[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    castingPost(body: Casting | undefined): Observable<Casting>;
    /**
     * @return Success
     */
    actuales(): Observable<CastingListElement[]>;
    /**
     * @return Success
     */
    id(id: string): Observable<Casting>;
    /**
     * @return Success
     */
    anonimo(id: string): Observable<Casting>;
    /**
     * @param body (optional) 
     * @return Success
     */
    castingPut(id: string, body: Casting | undefined): Observable<void>;
    /**
     * @return Success
     */
    castingDelete(castingId: string): Observable<CastingListElement>;
    /**
     * @param body (optional) 
     * @return Success
     */
    contactos(castingId: string, body: ContactoUsuario[] | undefined): Observable<ContactoUsuario[]>;
    /**
     * @return Success
     */
    logoGet(castingId: string): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    logoPut(castingId: string, body: string | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    eventos(castingId: string, body: EventoCasting[] | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    categoriasPut(castingId: string, body: CategoriaCasting[] | undefined): Observable<void>;
    /**
     * @return Success
     */
    modeloPut(castingId: string, modeloId: string, categoriaId: string): Observable<void>;
    /**
     * @return Success
     */
    modeloDelete(castingId: string, modeloId: string, categoriaId: string): Observable<void>;
    /**
     * @return Success
     */
    consecutivo(castingId: string, numModelo: number, categoriaId: string): Observable<ModeloCastingReview>;
    /**
     * @return Success
     */
    revisor(castingId: string): Observable<SelectorCastingCategoria>;
    /**
     * @return Success
     */
    selector(castingId: string): Observable<SelectorCastingCategoria>;
    /**
     * @param body (optional) 
     * @return Success
     */
    comentariosPut(castingId: string, body: string | undefined): Observable<void>;
    /**
     * @return Success
     */
    comentariosDelete(castingId: string, comentarioId: string): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    comentarioPost(castingId: string, categoriaId: string, modeloId: string, body: string | undefined): Observable<ComentarioCategoriaModeloCasting>;
    /**
     * @return Success
     */
    comentarioDelete(castingId: string, categoriaId: string, modeloId: string, comentarioId: string): Observable<void>;
    /**
     * @return Success
     */
    like(castingId: string, categoriaId: string, modeloId: string, nivel: string): Observable<VotoModeloCategoria>;
    /**
     * @param personaId (optional) 
     * @return Success
     */
    categoriasGet(castingId: string, personaId: string | undefined): Observable<string[]>;
    /**
     * @param personaId (optional) 
     * @return Success
     */
    inscribir(castingId: string, categoriaId: string, personaId: string | undefined): Observable<void>;
    /**
     * @param personaId (optional) 
     * @return Success
     */
    abandonar(castingId: string, categoriaId: string, personaId: string | undefined): Observable<void>;
    /**
     * @return Success
     */
    estadocasting(castingId: string, estado: EstadoCasting): Observable<void>;
    /**
     * @return Success
     */
    bitacora(id: string): Observable<BitacoraCasting[]>;
    /**
     * @return Success
     */
    video(castingId: string, modeloId: string, categoriaId: string): Observable<ModeloCasting>;
    /**
     * @return Success
     */
    foto(castingId: string, modeloId: string, categoriaId: string): Observable<string>;
    /**
     * @return Success
     */
    modelos(castingId: string, categoriaId: string): Observable<Persona[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CastingClient implements ICastingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param inactivos (optional) 
     * @return Success
     */
    castingGet(inactivos: boolean | undefined, httpContext?: HttpContext): Observable<CastingListElement[]> {
        let url_ = this.baseUrl + "/api/Casting?";
        if (inactivos === null)
            throw new Error("The parameter 'inactivos' cannot be null.");
        else if (inactivos !== undefined)
            url_ += "Inactivos=" + encodeURIComponent("" + inactivos) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCastingGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCastingGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CastingListElement[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CastingListElement[]>;
        }));
    }

    protected processCastingGet(response: HttpResponseBase): Observable<CastingListElement[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CastingListElement[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CastingListElement[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    castingPost(body: Casting | undefined, httpContext?: HttpContext): Observable<Casting> {
        let url_ = this.baseUrl + "/api/Casting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCastingPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCastingPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Casting>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Casting>;
        }));
    }

    protected processCastingPost(response: HttpResponseBase): Observable<Casting> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Casting;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Casting>(null as any);
    }

    /**
     * @return Success
     */
    actuales(httpContext?: HttpContext): Observable<CastingListElement[]> {
        let url_ = this.baseUrl + "/api/Casting/actuales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActuales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActuales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CastingListElement[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CastingListElement[]>;
        }));
    }

    protected processActuales(response: HttpResponseBase): Observable<CastingListElement[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CastingListElement[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CastingListElement[]>(null as any);
    }

    /**
     * @return Success
     */
    id(id: string, httpContext?: HttpContext): Observable<Casting> {
        let url_ = this.baseUrl + "/api/Casting/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Casting>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Casting>;
        }));
    }

    protected processId(response: HttpResponseBase): Observable<Casting> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Casting;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Casting>(null as any);
    }

    /**
     * @return Success
     */
    anonimo(id: string, httpContext?: HttpContext): Observable<Casting> {
        let url_ = this.baseUrl + "/api/Casting/anonimo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnonimo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnonimo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Casting>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Casting>;
        }));
    }

    protected processAnonimo(response: HttpResponseBase): Observable<Casting> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Casting;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Casting>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    castingPut(id: string, body: Casting | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCastingPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCastingPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCastingPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    castingDelete(castingId: string, httpContext?: HttpContext): Observable<CastingListElement> {
        let url_ = this.baseUrl + "/api/Casting/{CastingId}";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{CastingId}", encodeURIComponent("" + castingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCastingDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCastingDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CastingListElement>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CastingListElement>;
        }));
    }

    protected processCastingDelete(response: HttpResponseBase): Observable<CastingListElement> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CastingListElement;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CastingListElement>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    contactos(castingId: string, body: ContactoUsuario[] | undefined, httpContext?: HttpContext): Observable<ContactoUsuario[]> {
        let url_ = this.baseUrl + "/api/Casting/contactos/{castingId}";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactoUsuario[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactoUsuario[]>;
        }));
    }

    protected processContactos(response: HttpResponseBase): Observable<ContactoUsuario[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ContactoUsuario[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactoUsuario[]>(null as any);
    }

    /**
     * @return Success
     */
    logoGet(castingId: string, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/api/Casting/{CastingId}/logo";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{CastingId}", encodeURIComponent("" + castingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogoGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogoGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processLogoGet(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    logoPut(castingId: string, body: string | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/logo";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogoPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogoPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogoPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    eventos(castingId: string, body: EventoCasting[] | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/eventos";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEventos(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoriasPut(castingId: string, body: CategoriaCasting[] | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categorias";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriasPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriasPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCategoriasPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    modeloPut(castingId: string, modeloId: string, categoriaId: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/modelo/{modeloId}";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (modeloId === undefined || modeloId === null)
            throw new Error("The parameter 'modeloId' must be defined.");
        url_ = url_.replace("{modeloId}", encodeURIComponent("" + modeloId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModeloPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModeloPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processModeloPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    modeloDelete(castingId: string, modeloId: string, categoriaId: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/modelo/{modeloId}";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (modeloId === undefined || modeloId === null)
            throw new Error("The parameter 'modeloId' must be defined.");
        url_ = url_.replace("{modeloId}", encodeURIComponent("" + modeloId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModeloDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModeloDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processModeloDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    consecutivo(castingId: string, numModelo: number, categoriaId: string, httpContext?: HttpContext): Observable<ModeloCastingReview> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/modelo/{numModelo}/consecutivo";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (numModelo === undefined || numModelo === null)
            throw new Error("The parameter 'numModelo' must be defined.");
        url_ = url_.replace("{numModelo}", encodeURIComponent("" + numModelo));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsecutivo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsecutivo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModeloCastingReview>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModeloCastingReview>;
        }));
    }

    protected processConsecutivo(response: HttpResponseBase): Observable<ModeloCastingReview> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModeloCastingReview;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModeloCastingReview>(null as any);
    }

    /**
     * @return Success
     */
    revisor(castingId: string, httpContext?: HttpContext): Observable<SelectorCastingCategoria> {
        let url_ = this.baseUrl + "/api/Casting/{CastingId}/selector/revisor";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{CastingId}", encodeURIComponent("" + castingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevisor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevisor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectorCastingCategoria>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectorCastingCategoria>;
        }));
    }

    protected processRevisor(response: HttpResponseBase): Observable<SelectorCastingCategoria> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectorCastingCategoria;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectorCastingCategoria>(null as any);
    }

    /**
     * @return Success
     */
    selector(castingId: string, httpContext?: HttpContext): Observable<SelectorCastingCategoria> {
        let url_ = this.baseUrl + "/api/Casting/{CastingId}/selector";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{CastingId}", encodeURIComponent("" + castingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectorCastingCategoria>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectorCastingCategoria>;
        }));
    }

    protected processSelector(response: HttpResponseBase): Observable<SelectorCastingCategoria> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SelectorCastingCategoria;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectorCastingCategoria>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    comentariosPut(castingId: string, body: string | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/comentarios";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComentariosPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComentariosPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processComentariosPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    comentariosDelete(castingId: string, comentarioId: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/comentarios/{comentarioId}";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (comentarioId === undefined || comentarioId === null)
            throw new Error("The parameter 'comentarioId' must be defined.");
        url_ = url_.replace("{comentarioId}", encodeURIComponent("" + comentarioId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComentariosDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComentariosDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processComentariosDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    comentarioPost(castingId: string, categoriaId: string, modeloId: string, body: string | undefined, httpContext?: HttpContext): Observable<ComentarioCategoriaModeloCasting> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/modelo/{modeloId}/comentario";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        if (modeloId === undefined || modeloId === null)
            throw new Error("The parameter 'modeloId' must be defined.");
        url_ = url_.replace("{modeloId}", encodeURIComponent("" + modeloId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComentarioPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComentarioPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComentarioCategoriaModeloCasting>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComentarioCategoriaModeloCasting>;
        }));
    }

    protected processComentarioPost(response: HttpResponseBase): Observable<ComentarioCategoriaModeloCasting> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ComentarioCategoriaModeloCasting;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComentarioCategoriaModeloCasting>(null as any);
    }

    /**
     * @return Success
     */
    comentarioDelete(castingId: string, categoriaId: string, modeloId: string, comentarioId: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/modelo/{modeloId}/comentario/{comentarioId}";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        if (modeloId === undefined || modeloId === null)
            throw new Error("The parameter 'modeloId' must be defined.");
        url_ = url_.replace("{modeloId}", encodeURIComponent("" + modeloId));
        if (comentarioId === undefined || comentarioId === null)
            throw new Error("The parameter 'comentarioId' must be defined.");
        url_ = url_.replace("{comentarioId}", encodeURIComponent("" + comentarioId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComentarioDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComentarioDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processComentarioDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    like(castingId: string, categoriaId: string, modeloId: string, nivel: string, httpContext?: HttpContext): Observable<VotoModeloCategoria> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/modelo/{modeloId}/like/{nivel}";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        if (modeloId === undefined || modeloId === null)
            throw new Error("The parameter 'modeloId' must be defined.");
        url_ = url_.replace("{modeloId}", encodeURIComponent("" + modeloId));
        if (nivel === undefined || nivel === null)
            throw new Error("The parameter 'nivel' must be defined.");
        url_ = url_.replace("{nivel}", encodeURIComponent("" + nivel));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLike(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VotoModeloCategoria>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VotoModeloCategoria>;
        }));
    }

    protected processLike(response: HttpResponseBase): Observable<VotoModeloCategoria> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VotoModeloCategoria;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VotoModeloCategoria>(null as any);
    }

    /**
     * @param personaId (optional) 
     * @return Success
     */
    categoriasGet(castingId: string, personaId: string | undefined, httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/modelo/categorias?";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (personaId === null)
            throw new Error("The parameter 'personaId' cannot be null.");
        else if (personaId !== undefined)
            url_ += "personaId=" + encodeURIComponent("" + personaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoriasGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoriasGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processCategoriasGet(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * @param personaId (optional) 
     * @return Success
     */
    inscribir(castingId: string, categoriaId: string, personaId: string | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/inscribir?";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        if (personaId === null)
            throw new Error("The parameter 'personaId' cannot be null.");
        else if (personaId !== undefined)
            url_ += "personaId=" + encodeURIComponent("" + personaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInscribir(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInscribir(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInscribir(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param personaId (optional) 
     * @return Success
     */
    abandonar(castingId: string, categoriaId: string, personaId: string | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/abandonar?";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        if (personaId === null)
            throw new Error("The parameter 'personaId' cannot be null.");
        else if (personaId !== undefined)
            url_ += "personaId=" + encodeURIComponent("" + personaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAbandonar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAbandonar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAbandonar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    estadocasting(castingId: string, estado: EstadoCasting, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Casting/estadocasting/{castingId}/{estado}";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (estado === undefined || estado === null)
            throw new Error("The parameter 'estado' must be defined.");
        url_ = url_.replace("{estado}", encodeURIComponent("" + estado));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEstadocasting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEstadocasting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEstadocasting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    bitacora(id: string, httpContext?: HttpContext): Observable<BitacoraCasting[]> {
        let url_ = this.baseUrl + "/api/Casting/bitacora/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBitacora(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBitacora(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BitacoraCasting[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BitacoraCasting[]>;
        }));
    }

    protected processBitacora(response: HttpResponseBase): Observable<BitacoraCasting[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BitacoraCasting[];
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BitacoraCasting[]>(null as any);
    }

    /**
     * @return Success
     */
    video(castingId: string, modeloId: string, categoriaId: string, httpContext?: HttpContext): Observable<ModeloCasting> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/modelo/{modeloId}/video";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (modeloId === undefined || modeloId === null)
            throw new Error("The parameter 'modeloId' must be defined.");
        url_ = url_.replace("{modeloId}", encodeURIComponent("" + modeloId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVideo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModeloCasting>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModeloCasting>;
        }));
    }

    protected processVideo(response: HttpResponseBase): Observable<ModeloCasting> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ModeloCasting;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModeloCasting>(null as any);
    }

    /**
     * @return Success
     */
    foto(castingId: string, modeloId: string, categoriaId: string, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/modelo/{modeloId}/foto";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (modeloId === undefined || modeloId === null)
            throw new Error("The parameter 'modeloId' must be defined.");
        url_ = url_.replace("{modeloId}", encodeURIComponent("" + modeloId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processFoto(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @return Success
     */
    modelos(castingId: string, categoriaId: string, httpContext?: HttpContext): Observable<Persona[]> {
        let url_ = this.baseUrl + "/api/Casting/{castingId}/categoria/{categoriaId}/modelos";
        if (castingId === undefined || castingId === null)
            throw new Error("The parameter 'castingId' must be defined.");
        url_ = url_.replace("{castingId}", encodeURIComponent("" + castingId));
        if (categoriaId === undefined || categoriaId === null)
            throw new Error("The parameter 'categoriaId' must be defined.");
        url_ = url_.replace("{categoriaId}", encodeURIComponent("" + categoriaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModelos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModelos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Persona[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Persona[]>;
        }));
    }

    protected processModelos(response: HttpResponseBase): Observable<Persona[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Persona[];
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Persona[]>(null as any);
    }
}

export interface IClientesClient {
    /**
     * @return Success
     */
    config(): Observable<ClienteView>;
    /**
     * @param url (optional) 
     * @return Success
     */
    porurl(url: string | undefined): Observable<Cliente>;
    /**
     * @return Success
     */
    contactos(): Observable<ContactoUsuario[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ClientesClient implements IClientesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    config(httpContext?: HttpContext): Observable<ClienteView> {
        let url_ = this.baseUrl + "/clientes/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClienteView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClienteView>;
        }));
    }

    protected processConfig(response: HttpResponseBase): Observable<ClienteView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClienteView;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClienteView>(null as any);
    }

    /**
     * @param url (optional) 
     * @return Success
     */
    porurl(url: string | undefined, httpContext?: HttpContext): Observable<Cliente> {
        let url_ = this.baseUrl + "/clientes/porurl?";
        if (url === null)
            throw new Error("The parameter 'url' cannot be null.");
        else if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPorurl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPorurl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Cliente>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Cliente>;
        }));
    }

    protected processPorurl(response: HttpResponseBase): Observable<Cliente> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Cliente;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Cliente>(null as any);
    }

    /**
     * @return Success
     */
    contactos(httpContext?: HttpContext): Observable<ContactoUsuario[]> {
        let url_ = this.baseUrl + "/clientes/contactos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContactos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContactos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactoUsuario[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactoUsuario[]>;
        }));
    }

    protected processContactos(response: HttpResponseBase): Observable<ContactoUsuario[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ContactoUsuario[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactoUsuario[]>(null as any);
    }
}

export interface IContenidoClient {
    /**
     * @param uid (optional) 
     * @param body (optional) 
     * @return Success
     */
    mi(uid: string | undefined, body: string | undefined): Observable<MediaCliente>;
    /**
     * @return Success
     */
    medios(id: string): Observable<MediaCliente>;
    /**
     * @param uid (optional) 
     * @return Success
     */
    principal(uid: string | undefined, id: string): Observable<MediaCliente>;
    /**
     * @param uid (optional) 
     * @return Success
     */
    bloqueo(uid: string | undefined, id: string): Observable<MediaCliente>;
    /**
     * @param uid (optional) 
     * @return Success
     */
    contenidoDelete(uid: string | undefined, id: string): Observable<MediaCliente>;
    /**
     * @return Success
     */
    stream(usuarioid: string, id: string, tipo: string): Observable<void>;
    /**
     * @return Success
     */
    contenidoGet(usuarioid: string, id: string, tipo: string): Observable<void>;
    /**
     * @param uid (optional) 
     * @param id (optional) 
     * @param formFile (optional) 
     * @param titulo (optional) 
     * @param castingId (optional) 
     * @return Success
     */
    documentacion(uid: string | undefined, id: string | undefined, formFile: FileParameter | undefined, titulo: string | undefined, castingId: string | undefined): Observable<ElementoMediaCliente>;
    /**
     * @param uid (optional) 
     * @param id (optional) 
     * @param formFile (optional) 
     * @param titulo (optional) 
     * @param castingId (optional) 
     * @return Success
     */
    carga(uid: string | undefined, id: string | undefined, formFile: FileParameter | undefined, titulo: string | undefined, castingId: string | undefined): Observable<ElementoMediaCliente>;
}

@Injectable({
    providedIn: 'root'
})
export class ContenidoClient implements IContenidoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param uid (optional) 
     * @param body (optional) 
     * @return Success
     */
    mi(uid: string | undefined, body: string | undefined, httpContext?: HttpContext): Observable<MediaCliente> {
        let url_ = this.baseUrl + "/contenido/mi?";
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MediaCliente>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MediaCliente>;
        }));
    }

    protected processMi(response: HttpResponseBase): Observable<MediaCliente> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MediaCliente;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MediaCliente>(null as any);
    }

    /**
     * @return Success
     */
    medios(id: string, httpContext?: HttpContext): Observable<MediaCliente> {
        let url_ = this.baseUrl + "/contenido/medios/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMedios(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMedios(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MediaCliente>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MediaCliente>;
        }));
    }

    protected processMedios(response: HttpResponseBase): Observable<MediaCliente> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MediaCliente;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MediaCliente>(null as any);
    }

    /**
     * @param uid (optional) 
     * @return Success
     */
    principal(uid: string | undefined, id: string, httpContext?: HttpContext): Observable<MediaCliente> {
        let url_ = this.baseUrl + "/contenido/principal/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrincipal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrincipal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MediaCliente>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MediaCliente>;
        }));
    }

    protected processPrincipal(response: HttpResponseBase): Observable<MediaCliente> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MediaCliente;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MediaCliente>(null as any);
    }

    /**
     * @param uid (optional) 
     * @return Success
     */
    bloqueo(uid: string | undefined, id: string, httpContext?: HttpContext): Observable<MediaCliente> {
        let url_ = this.baseUrl + "/contenido/bloqueo/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBloqueo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBloqueo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MediaCliente>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MediaCliente>;
        }));
    }

    protected processBloqueo(response: HttpResponseBase): Observable<MediaCliente> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MediaCliente;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MediaCliente>(null as any);
    }

    /**
     * @param uid (optional) 
     * @return Success
     */
    contenidoDelete(uid: string | undefined, id: string, httpContext?: HttpContext): Observable<MediaCliente> {
        let url_ = this.baseUrl + "/contenido/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContenidoDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContenidoDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MediaCliente>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MediaCliente>;
        }));
    }

    protected processContenidoDelete(response: HttpResponseBase): Observable<MediaCliente> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MediaCliente;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MediaCliente>(null as any);
    }

    /**
     * @return Success
     */
    stream(usuarioid: string, id: string, tipo: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/contenido/stream/{usuarioid}/{id}/{tipo}";
        if (usuarioid === undefined || usuarioid === null)
            throw new Error("The parameter 'usuarioid' must be defined.");
        url_ = url_.replace("{usuarioid}", encodeURIComponent("" + usuarioid));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (tipo === undefined || tipo === null)
            throw new Error("The parameter 'tipo' must be defined.");
        url_ = url_.replace("{tipo}", encodeURIComponent("" + tipo));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStream(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStream(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStream(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    contenidoGet(usuarioid: string, id: string, tipo: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/contenido/{usuarioid}/{id}/{tipo}";
        if (usuarioid === undefined || usuarioid === null)
            throw new Error("The parameter 'usuarioid' must be defined.");
        url_ = url_.replace("{usuarioid}", encodeURIComponent("" + usuarioid));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (tipo === undefined || tipo === null)
            throw new Error("The parameter 'tipo' must be defined.");
        url_ = url_.replace("{tipo}", encodeURIComponent("" + tipo));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processContenidoGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processContenidoGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processContenidoGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param uid (optional) 
     * @param id (optional) 
     * @param formFile (optional) 
     * @param titulo (optional) 
     * @param castingId (optional) 
     * @return Success
     */
    documentacion(uid: string | undefined, id: string | undefined, formFile: FileParameter | undefined, titulo: string | undefined, castingId: string | undefined, httpContext?: HttpContext): Observable<ElementoMediaCliente> {
        let url_ = this.baseUrl + "/contenido/documentacion?";
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (formFile === null || formFile === undefined)
            throw new Error("The parameter 'formFile' cannot be null.");
        else
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");
        if (titulo === null || titulo === undefined)
            throw new Error("The parameter 'titulo' cannot be null.");
        else
            content_.append("Titulo", titulo.toString());
        if (castingId === null || castingId === undefined)
            throw new Error("The parameter 'castingId' cannot be null.");
        else
            content_.append("CastingId", castingId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDocumentacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDocumentacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElementoMediaCliente>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElementoMediaCliente>;
        }));
    }

    protected processDocumentacion(response: HttpResponseBase): Observable<ElementoMediaCliente> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ElementoMediaCliente;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElementoMediaCliente>(null as any);
    }

    /**
     * @param uid (optional) 
     * @param id (optional) 
     * @param formFile (optional) 
     * @param titulo (optional) 
     * @param castingId (optional) 
     * @return Success
     */
    carga(uid: string | undefined, id: string | undefined, formFile: FileParameter | undefined, titulo: string | undefined, castingId: string | undefined, httpContext?: HttpContext): Observable<ElementoMediaCliente> {
        let url_ = this.baseUrl + "/contenido/carga?";
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (formFile === null || formFile === undefined)
            throw new Error("The parameter 'formFile' cannot be null.");
        else
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");
        if (titulo === null || titulo === undefined)
            throw new Error("The parameter 'titulo' cannot be null.");
        else
            content_.append("Titulo", titulo.toString());
        if (castingId === null || castingId === undefined)
            throw new Error("The parameter 'castingId' cannot be null.");
        else
            content_.append("CastingId", castingId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCarga(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCarga(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ElementoMediaCliente>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ElementoMediaCliente>;
        }));
    }

    protected processCarga(response: HttpResponseBase): Observable<ElementoMediaCliente> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ElementoMediaCliente;
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Server Error", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElementoMediaCliente>(null as any);
    }
}

export interface IDemoClient {
    /**
     * @return Success
     */
    demo(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class DemoClient implements IDemoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    demo(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/demo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDemo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDemo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDemo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface IDiagnosticoClient {
    /**
     * @return Success
     */
    diagnostico(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class DiagnosticoClient implements IDiagnosticoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    diagnostico(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/Diagnostico";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiagnostico(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiagnostico(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDiagnostico(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface IGoogleWebhooksClient {
    /**
     * @return Success
     */
    token(): Observable<void>;
    /**
     * @return Success
     */
    echo(): Observable<void>;
    /**
     * @return Success
     */
    eventoDelete(id: string): Observable<void>;
    /**
     * @return Success
     */
    eventoGet(id: string): Observable<void>;
    /**
     * @param x_Goog_Channel_ID (optional) 
     * @param x_Goog_Channel_Token (optional) 
     * @param x_Goog_Channel_Expiration (optional) 
     * @param x_Goog_Resource_ID (optional) 
     * @param x_Goog_Resource_URI (optional) 
     * @param x_Goog_Resource_State (optional) 
     * @param x_Goog_Message_Number (optional) 
     * @param x_Goog_Changed (optional) 
     * @return Success
     */
    drivechange(x_Goog_Channel_ID: string | undefined, x_Goog_Channel_Token: string | undefined, x_Goog_Channel_Expiration: string | undefined, x_Goog_Resource_ID: string | undefined, x_Goog_Resource_URI: string | undefined, x_Goog_Resource_State: string | undefined, x_Goog_Message_Number: string | undefined, x_Goog_Changed: string | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class GoogleWebhooksClient implements IGoogleWebhooksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    token(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/GoogleWebhooks/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    echo(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/GoogleWebhooks/echo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEcho(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEcho(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEcho(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    eventoDelete(id: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/GoogleWebhooks/evento/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventoDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventoDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEventoDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    eventoGet(id: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/GoogleWebhooks/evento/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventoGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventoGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEventoGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param x_Goog_Channel_ID (optional) 
     * @param x_Goog_Channel_Token (optional) 
     * @param x_Goog_Channel_Expiration (optional) 
     * @param x_Goog_Resource_ID (optional) 
     * @param x_Goog_Resource_URI (optional) 
     * @param x_Goog_Resource_State (optional) 
     * @param x_Goog_Message_Number (optional) 
     * @param x_Goog_Changed (optional) 
     * @return Success
     */
    drivechange(x_Goog_Channel_ID: string | undefined, x_Goog_Channel_Token: string | undefined, x_Goog_Channel_Expiration: string | undefined, x_Goog_Resource_ID: string | undefined, x_Goog_Resource_URI: string | undefined, x_Goog_Resource_State: string | undefined, x_Goog_Message_Number: string | undefined, x_Goog_Changed: string | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/GoogleWebhooks/drivechange";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "X-Goog-Channel-ID": x_Goog_Channel_ID !== undefined && x_Goog_Channel_ID !== null ? "" + x_Goog_Channel_ID : "",
                "X-Goog-Channel-Token": x_Goog_Channel_Token !== undefined && x_Goog_Channel_Token !== null ? "" + x_Goog_Channel_Token : "",
                "X-Goog-Channel-Expiration": x_Goog_Channel_Expiration !== undefined && x_Goog_Channel_Expiration !== null ? "" + x_Goog_Channel_Expiration : "",
                "X-Goog-Resource-ID": x_Goog_Resource_ID !== undefined && x_Goog_Resource_ID !== null ? "" + x_Goog_Resource_ID : "",
                "X-Goog-Resource-URI": x_Goog_Resource_URI !== undefined && x_Goog_Resource_URI !== null ? "" + x_Goog_Resource_URI : "",
                "X-Goog-Resource-State": x_Goog_Resource_State !== undefined && x_Goog_Resource_State !== null ? "" + x_Goog_Resource_State : "",
                "X-Goog-Message-Number": x_Goog_Message_Number !== undefined && x_Goog_Message_Number !== null ? "" + x_Goog_Message_Number : "",
                "X-Goog-Changed": x_Goog_Changed !== undefined && x_Goog_Changed !== null ? "" + x_Goog_Changed : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDrivechange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDrivechange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDrivechange(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface IPersonaClient {
    /**
     * @return Success
     */
    newPerfil(): Observable<Persona>;
    /**
     * @return Success
     */
    mi(): Observable<Persona>;
    /**
     * @param body (optional) 
     * @return Success
     */
    buscar(body: BusquedaPersonasRequestPaginado | undefined): Observable<PersonaResponsePaginado>;
    /**
     * @param body (optional) 
     * @return Success
     */
    idPost(body: BusquedaPersonasIdRequestPaginado | undefined): Observable<PersonaResponsePaginado>;
    /**
     * @return Success
     */
    personaGet(usuarioid: string): Observable<Persona>;
    /**
     * @return Success
     */
    idGet(personaid: string): Observable<Persona>;
    /**
     * @param body (optional) 
     * @return Created
     */
    personaPost(body: Persona | undefined): Observable<Persona>;
    /**
     * @param body (optional) 
     * @return Success
     */
    personaPut(id: string, body: Persona | undefined): Observable<void>;
    /**
     * @return Success
     */
    personaDelete(id: string): Observable<void>;
    /**
     * @param uid (optional) 
     * @return Success
     */
    activos(uid: string | undefined): Observable<CastingPersonaCompleto[]>;
    /**
     * @return Success
     */
    catalogo(tipo: string): Observable<CatalogoBase>;
    /**
     * @return Success
     */
    perfil(): Observable<CatalogoBase[]>;
    /**
     * @return Success
     */
    perfilusuario(): Observable<InformacionPerfil>;
    /**
     * @param body (optional) 
     * @return Success
     */
    perfilpublicoPost(body: PerfilPublicoUsuario | undefined): Observable<void>;
    /**
     * @return Success
     */
    perfilpublicoGet(usuarioId: string): Observable<PerfilPublicoUsuario>;
    /**
     * @return Success
     */
    porusuarioPost(personaid: string): Observable<PersonasUsuario>;
    /**
     * @return Success
     */
    porusuarioDelete(personaid: string): Observable<void>;
    /**
     * @return Success
     */
    porusuarioGet(): Observable<MapaUsuarioNombre[]>;
    /**
     * @return Success
     */
    consentimiento(consentimientoId: string): Observable<AceptacionConsentimiento>;
}

@Injectable({
    providedIn: 'root'
})
export class PersonaClient implements IPersonaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    newPerfil(httpContext?: HttpContext): Observable<Persona> {
        let url_ = this.baseUrl + "/persona/NewPerfil";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewPerfil(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewPerfil(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Persona>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Persona>;
        }));
    }

    protected processNewPerfil(response: HttpResponseBase): Observable<Persona> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Persona;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Persona>(null as any);
    }

    /**
     * @return Success
     */
    mi(httpContext?: HttpContext): Observable<Persona> {
        let url_ = this.baseUrl + "/persona/mi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Persona>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Persona>;
        }));
    }

    protected processMi(response: HttpResponseBase): Observable<Persona> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Persona;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Persona>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    buscar(body: BusquedaPersonasRequestPaginado | undefined, httpContext?: HttpContext): Observable<PersonaResponsePaginado> {
        let url_ = this.baseUrl + "/persona/buscar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuscar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuscar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonaResponsePaginado>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonaResponsePaginado>;
        }));
    }

    protected processBuscar(response: HttpResponseBase): Observable<PersonaResponsePaginado> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PersonaResponsePaginado;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonaResponsePaginado>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    idPost(body: BusquedaPersonasIdRequestPaginado | undefined, httpContext?: HttpContext): Observable<PersonaResponsePaginado> {
        let url_ = this.baseUrl + "/persona/buscar/id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIdPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIdPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonaResponsePaginado>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonaResponsePaginado>;
        }));
    }

    protected processIdPost(response: HttpResponseBase): Observable<PersonaResponsePaginado> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PersonaResponsePaginado;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonaResponsePaginado>(null as any);
    }

    /**
     * @return Success
     */
    personaGet(usuarioid: string, httpContext?: HttpContext): Observable<Persona> {
        let url_ = this.baseUrl + "/persona/{usuarioid}";
        if (usuarioid === undefined || usuarioid === null)
            throw new Error("The parameter 'usuarioid' must be defined.");
        url_ = url_.replace("{usuarioid}", encodeURIComponent("" + usuarioid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonaGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonaGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Persona>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Persona>;
        }));
    }

    protected processPersonaGet(response: HttpResponseBase): Observable<Persona> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Persona;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Persona>(null as any);
    }

    /**
     * @return Success
     */
    idGet(personaid: string, httpContext?: HttpContext): Observable<Persona> {
        let url_ = this.baseUrl + "/persona/persona/id/{personaid}";
        if (personaid === undefined || personaid === null)
            throw new Error("The parameter 'personaid' must be defined.");
        url_ = url_.replace("{personaid}", encodeURIComponent("" + personaid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIdGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIdGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Persona>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Persona>;
        }));
    }

    protected processIdGet(response: HttpResponseBase): Observable<Persona> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Persona;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Persona>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    personaPost(body: Persona | undefined, httpContext?: HttpContext): Observable<Persona> {
        let url_ = this.baseUrl + "/persona";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonaPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonaPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Persona>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Persona>;
        }));
    }

    protected processPersonaPost(response: HttpResponseBase): Observable<Persona> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Persona;
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Persona>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    personaPut(id: string, body: Persona | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/persona/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonaPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonaPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPersonaPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    personaDelete(id: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/persona/{Id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPersonaDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPersonaDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPersonaDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param uid (optional) 
     * @return Success
     */
    activos(uid: string | undefined, httpContext?: HttpContext): Observable<CastingPersonaCompleto[]> {
        let url_ = this.baseUrl + "/persona/castings/activos?";
        if (uid === null)
            throw new Error("The parameter 'uid' cannot be null.");
        else if (uid !== undefined)
            url_ += "uid=" + encodeURIComponent("" + uid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CastingPersonaCompleto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CastingPersonaCompleto[]>;
        }));
    }

    protected processActivos(response: HttpResponseBase): Observable<CastingPersonaCompleto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CastingPersonaCompleto[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CastingPersonaCompleto[]>(null as any);
    }

    /**
     * @return Success
     */
    catalogo(tipo: string, httpContext?: HttpContext): Observable<CatalogoBase> {
        let url_ = this.baseUrl + "/persona/catalogo/{tipo}";
        if (tipo === undefined || tipo === null)
            throw new Error("The parameter 'tipo' must be defined.");
        url_ = url_.replace("{tipo}", encodeURIComponent("" + tipo));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCatalogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCatalogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogoBase>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogoBase>;
        }));
    }

    protected processCatalogo(response: HttpResponseBase): Observable<CatalogoBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogoBase;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CatalogoBase>(null as any);
    }

    /**
     * @return Success
     */
    perfil(httpContext?: HttpContext): Observable<CatalogoBase[]> {
        let url_ = this.baseUrl + "/persona/catalogo/perfil";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerfil(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerfil(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CatalogoBase[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CatalogoBase[]>;
        }));
    }

    protected processPerfil(response: HttpResponseBase): Observable<CatalogoBase[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CatalogoBase[];
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CatalogoBase[]>(null as any);
    }

    /**
     * @return Success
     */
    perfilusuario(httpContext?: HttpContext): Observable<InformacionPerfil> {
        let url_ = this.baseUrl + "/persona/perfilusuario";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerfilusuario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerfilusuario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InformacionPerfil>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InformacionPerfil>;
        }));
    }

    protected processPerfilusuario(response: HttpResponseBase): Observable<InformacionPerfil> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InformacionPerfil;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InformacionPerfil>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    perfilpublicoPost(body: PerfilPublicoUsuario | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/persona/perfilpublico";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerfilpublicoPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerfilpublicoPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPerfilpublicoPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    perfilpublicoGet(usuarioId: string, httpContext?: HttpContext): Observable<PerfilPublicoUsuario> {
        let url_ = this.baseUrl + "/persona/perfilpublico/{UsuarioId}";
        if (usuarioId === undefined || usuarioId === null)
            throw new Error("The parameter 'usuarioId' must be defined.");
        url_ = url_.replace("{UsuarioId}", encodeURIComponent("" + usuarioId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerfilpublicoGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerfilpublicoGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PerfilPublicoUsuario>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PerfilPublicoUsuario>;
        }));
    }

    protected processPerfilpublicoGet(response: HttpResponseBase): Observable<PerfilPublicoUsuario> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PerfilPublicoUsuario;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PerfilPublicoUsuario>(null as any);
    }

    /**
     * @return Success
     */
    porusuarioPost(personaid: string, httpContext?: HttpContext): Observable<PersonasUsuario> {
        let url_ = this.baseUrl + "/persona/porusuario/{personaid}";
        if (personaid === undefined || personaid === null)
            throw new Error("The parameter 'personaid' must be defined.");
        url_ = url_.replace("{personaid}", encodeURIComponent("" + personaid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPorusuarioPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPorusuarioPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonasUsuario>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonasUsuario>;
        }));
    }

    protected processPorusuarioPost(response: HttpResponseBase): Observable<PersonasUsuario> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PersonasUsuario;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonasUsuario>(null as any);
    }

    /**
     * @return Success
     */
    porusuarioDelete(personaid: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/persona/porusuario/{personaid}";
        if (personaid === undefined || personaid === null)
            throw new Error("The parameter 'personaid' must be defined.");
        url_ = url_.replace("{personaid}", encodeURIComponent("" + personaid));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPorusuarioDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPorusuarioDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPorusuarioDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    porusuarioGet(httpContext?: HttpContext): Observable<MapaUsuarioNombre[]> {
        let url_ = this.baseUrl + "/persona/porusuario";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPorusuarioGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPorusuarioGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MapaUsuarioNombre[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MapaUsuarioNombre[]>;
        }));
    }

    protected processPorusuarioGet(response: HttpResponseBase): Observable<MapaUsuarioNombre[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MapaUsuarioNombre[];
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MapaUsuarioNombre[]>(null as any);
    }

    /**
     * @return Success
     */
    consentimiento(consentimientoId: string, httpContext?: HttpContext): Observable<AceptacionConsentimiento> {
        let url_ = this.baseUrl + "/persona/consentimiento/{consentimientoId}";
        if (consentimientoId === undefined || consentimientoId === null)
            throw new Error("The parameter 'consentimientoId' must be defined.");
        url_ = url_.replace("{consentimientoId}", encodeURIComponent("" + consentimientoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsentimiento(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsentimiento(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AceptacionConsentimiento>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AceptacionConsentimiento>;
        }));
    }

    protected processConsentimiento(response: HttpResponseBase): Observable<AceptacionConsentimiento> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AceptacionConsentimiento;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AceptacionConsentimiento>(null as any);
    }
}

export interface IRegistroClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    registroPost(body: RegistroUsuario | undefined): Observable<void>;
    /**
     * @return Success
     */
    registroGet(id: string): Observable<InvitacionRegistro>;
    /**
     * @param body (optional) 
     * @return Success
     */
    completar(id: string, body: CreacionUsuario | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class RegistroClient implements IRegistroClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registroPost(body: RegistroUsuario | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/registro";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistroPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistroPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegistroPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    registroGet(id: string, httpContext?: HttpContext): Observable<InvitacionRegistro> {
        let url_ = this.baseUrl + "/registro/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistroGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistroGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvitacionRegistro>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvitacionRegistro>;
        }));
    }

    protected processRegistroGet(response: HttpResponseBase): Observable<InvitacionRegistro> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InvitacionRegistro;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvitacionRegistro>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completar(id: string, body: CreacionUsuario | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/registro/completar/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCompletar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface AccesoInformacion {
    profesionales?: boolean;
    amigos?: boolean;
}

export interface AceptacionConsentimiento {
    id?: string | undefined;
    fechaAceptacion?: Date;
}

export interface BitacoraCasting {
}

export interface BusquedaPersonas {
    clienteId?: string | undefined;
    generosId?: string[] | undefined;
    edadMinima?: number | undefined;
    edadMaxima?: number | undefined;
    tipoCuerpos?: TipoCuerpo[] | undefined;
    nombre?: string | undefined;
    etniasIds?: string[] | undefined;
    colorOjosIds?: string[] | undefined;
    tipoCabelloIds?: string[] | undefined;
    colorCabelloIds?: string[] | undefined;
    idiomasIds?: string[] | undefined;
    habilidadesIds?: string[] | undefined;
    ids?: string[] | undefined;
}

export interface BusquedaPersonasId {
    clienteId?: string | undefined;
    ids?: string[] | undefined;
}

export interface BusquedaPersonasIdRequestPaginado {
    request?: BusquedaPersonasId;
    ordernarASC?: boolean | undefined;
    ordenarPor?: string | undefined;
    pagina?: number;
    tamano?: number;
    contar?: boolean;
}

export interface BusquedaPersonasRequestPaginado {
    request?: BusquedaPersonas;
    ordernarASC?: boolean | undefined;
    ordenarPor?: string | undefined;
    pagina?: number;
    tamano?: number;
    contar?: boolean;
}

export interface Casting {
    id?: string | undefined;
    rev?: string | undefined;
    readonly deleted?: boolean;
    readonly conflicts?: string[] | undefined;
    readonly attachments?: CouchAttachment[] | undefined;
    clienteId?: string | undefined;
    nombre?: string | undefined;
    status?: EstadoCasting;
    nombreCliente?: string | undefined;
    fechaCreacionTicks?: number | undefined;
    usuarioId?: string | undefined;
    fechaApertura?: Date | undefined;
    fechaCierre?: Date | undefined;
    aceptaAutoInscripcion?: boolean;
    contactos?: ContactoCasting[] | undefined;
    descripcion?: string | undefined;
    comentarios?: ComentarioCasting[] | undefined;
    colaboradoresIds?: string[] | undefined;
    activo?: boolean;
    aperturaAutomatica?: boolean;
    cierreAutomatico?: boolean;
    categorias?: CategoriaCasting[] | undefined;
    logoCasting?: string | undefined;
    pernisosEcternos?: PermisosCasting;
    eventos?: EventoCasting[] | undefined;
    folderId?: string | undefined;
}

export interface CastingListElement {
    id?: string | undefined;
    nombre?: string | undefined;
    nombreCliente?: string | undefined;
    fechaApertura?: Date | undefined;
    fechaCierre?: Date | undefined;
    status?: EstadoCasting;
    aceptaAutoInscripcion?: boolean;
    activo?: boolean;
    aperturaAutomatica?: boolean;
    cierreAutomatico?: boolean;
    rol?: TipoRolCliente;
    logo?: string | undefined;
}

export interface CastingPersona {
    clienteId?: string | undefined;
    castingId?: string | undefined;
    declinado?: boolean;
    fechaAdicion?: Date;
    folderId?: string | undefined;
    channelId?: string | undefined;
    resourceId?: string | undefined;
}

export interface CastingPersonaCompleto {
    clienteId?: string | undefined;
    castingId?: string | undefined;
    declinado?: boolean;
    fechaAdicion?: Date;
    folderId?: string | undefined;
    channelId?: string | undefined;
    resourceId?: string | undefined;
    nombre?: string | undefined;
}

export interface CatalogoBase {
    id?: string | undefined;
    rev?: string | undefined;
    readonly deleted?: boolean;
    readonly conflicts?: string[] | undefined;
    readonly attachments?: CouchAttachment[] | undefined;
    tipoPropiedad?: string | undefined;
    clienteId?: string | undefined;
    elementos?: ElementoCatalogo[] | undefined;
}

export interface CategoriaCasting {
    id?: string | undefined;
    nombre?: string | undefined;
    descripcion?: string | undefined;
    busquedaDefault?: BusquedaPersonas;
    modelos?: ModeloCasting[] | undefined;
}

export interface Cliente {
    id?: string | undefined;
    rev?: string | undefined;
    readonly deleted?: boolean;
    readonly conflicts?: string[] | undefined;
    readonly attachments?: CouchAttachment[] | undefined;
    nombre?: string | undefined;
    url?: string | undefined;
    activo?: boolean;
    webLogoBase64?: string | undefined;
    mailLogoURL?: string | undefined;
    paisDefault?: string | undefined;
    contacto?: Contacto;
    documentacion?: DocumentoModelo[] | undefined;
    mostrarConsentimientos?: boolean;
    consentimientos?: Consentimiento[] | undefined;
}

export interface ClienteView {
    nombre?: string | undefined;
    url?: string | undefined;
    activo?: boolean;
    webLogoBase64?: string | undefined;
    mailLogoURL?: string | undefined;
    contacto?: Contacto;
    documentacion?: DocumentoModelo[] | undefined;
    mostrarConsentimientos?: boolean;
    consentimientos?: Consentimiento[] | undefined;
}

export interface ComentarioCasting {
    id?: string | undefined;
    fecha?: Date;
    usuarioId?: string | undefined;
    comentario?: string | undefined;
}

export interface ComentarioCategoriaModeloCasting {
    id?: string | undefined;
    fecha?: Date;
    usuarioId?: string | undefined;
    comentario?: string | undefined;
    categoriaId?: string | undefined;
    personaId?: string | undefined;
}

export interface Consentimiento {
    id?: string | undefined;
    idioma?: string | undefined;
    idiomaDefault?: boolean;
    titulo?: string | undefined;
    contenidoHTML?: string | undefined;
}

export interface Contacto {
    direccion?: string | undefined;
    email?: string | undefined;
    telefono?: string | undefined;
    twitter?: string | undefined;
    faceBook?: string | undefined;
    linkedIn?: string | undefined;
    instagram?: string | undefined;
    omitirDatos?: boolean;
    telefonoWhatsApp?: boolean | undefined;
    telSMS?: boolean | undefined;
    accesoDireccion?: AccesoInformacion;
    accesoEmail?: AccesoInformacion;
    accesoTelefono?: AccesoInformacion;
    accesoRedes?: AccesoInformacion;
}

export interface ContactoCasting {
    usuarioId?: string | undefined;
    nombreUsuario?: string | undefined;
    email?: string | undefined;
    confirmado?: boolean;
    rol?: TipoRolCliente;
    ultimoIngreso?: Date | undefined;
}

export interface ContactoUsuario {
    id?: string | undefined;
    email?: string | undefined;
    nombreUsuario?: string | undefined;
    rol?: TipoRolCliente;
    localizado?: boolean;
}

export interface CouchAttachment {
    readonly name?: string | undefined;
    readonly uri?: string | undefined;
    stub?: boolean;
    contentType?: string | undefined;
    readonly digest?: string | undefined;
    readonly length?: number | undefined;
    readonly revPos?: number | undefined;
}

export interface CreacionUsuario {
    email: string;
    contrasena: string;
    nombreUsuario: string;
}

export interface Documento {
    id?: string | undefined;
    idAlmacenamiento?: string | undefined;
}

export interface DocumentoModelo {
    id?: string | undefined;
    nombre?: string | undefined;
    obligatorio?: boolean;
}

export interface ElementoCatalogo {
    clave?: string | undefined;
    clavePadre?: string | undefined;
    texto?: string | undefined;
    idioma?: string | undefined;
}

export interface ElementoMediaCliente {
    id?: string | undefined;
    extension?: string | undefined;
    mimeType?: string | undefined;
    imagen?: boolean;
    video?: boolean;
    pdf?: boolean;
    permanente?: boolean;
    principal?: boolean;
    landscape?: boolean;
    tipo?: TipoMedio;
    frameVideoId?: string | undefined;
    titulo?: string | undefined;
    castingId?: string | undefined;
}

export interface EstablecerContrasena {
    actual?: string | undefined;
    nueva?: string | undefined;
}

export enum EstadoCasting {
    EnEdicion = "EnEdicion",
    Abierto = "Abierto",
    Cerrado = "Cerrado",
    Cancelado = "Cancelado",
}

export interface EventoCasting {
    id?: number;
    fechaInicial?: Date;
    fechaFinal?: Date;
    notas?: string | undefined;
    lugar?: string | undefined;
    coordenadas?: string | undefined;
}

export enum HttpCode {
    None = "None",
    Ok = "Ok",
    BadRequest = "BadRequest",
    Forbidden = "Forbidden",
    NotFound = "NotFound",
    Conflict = "Conflict",
}

export interface InformacionPerfil {
    nombreCompleto?: string | undefined;
    usuarioId?: string | undefined;
    alias?: string | undefined;
    avatarBase64?: string | undefined;
    requirePerfil?: boolean;
    tienePerfil?: boolean;
    datosCompletos?: boolean;
    roles?: TipoRolCliente[] | undefined;
    cosentimientosAceptados?: AceptacionConsentimiento[] | undefined;
}

export interface InvitacionRegistro {
    id?: string | undefined;
    rev?: string | undefined;
    readonly deleted?: boolean;
    readonly conflicts?: string[] | undefined;
    readonly attachments?: CouchAttachment[] | undefined;
    emitida?: Date;
    limiteUso?: Date;
    registro?: RegistroUsuario;
}

export interface MapaUsuarioNombre {
    id?: string | undefined;
    nombre?: string | undefined;
    email?: string | undefined;
}

export interface MediaCliente {
    usuarioId?: string | undefined;
    elementos?: ElementoMediaCliente[] | undefined;
}

export interface ModeloCasting {
    consecutivo?: number | undefined;
    personaId?: string | undefined;
    aceptada?: boolean;
    declinada?: boolean;
    origen?: OrigenInscripcion;
    imagenPortadaId?: string | undefined;
    videoPortadaId?: string | undefined;
    comentarios?: ComentarioCasting[] | undefined;
    votos?: VotoModeloCategoria[] | undefined;
    folderId?: string | undefined;
}

export interface ModeloCastingReview {
    personaId?: string | undefined;
    consecutivo?: number | undefined;
}

export enum OrigenInscripcion {
    Publico = "publico",
    Staff = "staff",
}

export interface PerfilPublicoUsuario {
    id?: string | undefined;
    nombre?: string | undefined;
    agenciaId?: string | undefined;
    avatar?: string | undefined;
}

export interface PermisosCasting {
    verRedesSociales?: boolean;
    verTelefono?: boolean;
    verDireccion?: boolean;
    verEmail?: boolean;
    verHabilidades?: boolean;
    verDatosGenerales?: boolean;
    verGaleriaPersonal?: boolean;
    verComentarios?: boolean;
}

export interface Persona {
    id?: string | undefined;
    rev?: string | undefined;
    readonly deleted?: boolean;
    readonly conflicts?: string[] | undefined;
    readonly attachments?: CouchAttachment[] | undefined;
    clientes?: string[] | undefined;
    consecutivo?: number | undefined;
    avatarBase64?: string | undefined;
    exclusivo: boolean;
    usuarioId?: string | undefined;
    nombre?: string | undefined;
    nombreArtistico?: string | undefined;
    nombreBusqueda?: string | undefined;
    apellido1?: string | undefined;
    apellido2?: string | undefined;
    generoId?: string | undefined;
    fechaNacimiento?: Date | undefined;
    ticksFechaNacimiento?: number;
    relacion: TipoRelacionPersona;
    paisOrigenId?: string | undefined;
    paisActualId?: string | undefined;
    datosCompletos?: boolean;
    estadoPaisId?: string | undefined;
    extranjero?: boolean;
    permisoTrabajo?: boolean;
    zonaHorariaId?: string | undefined;
    offsetHorario?: number | undefined;
    idiomasIds?: string[] | undefined;
    agenciasIds?: string[] | undefined;
    folderContenidoId?: string | undefined;
    documentos?: Documento[] | undefined;
    documentacionCompleta?: boolean | undefined;
    actividadesIds?: string[] | undefined;
    usuarioRegistroId?: string | undefined;
    fechaRegistro?: number | undefined;
    propiedadesFisicas?: PropiedadesFisicas;
    propiedadesVestuario?: PropiedadesVestuario;
    otroIdioma?: string | undefined;
    otroAgencia?: string | undefined;
    otroColorOjos?: string | undefined;
    otroColorCabello?: string | undefined;
    otroTipoCabello?: string | undefined;
    otroGrupoRacial?: string | undefined;
    otroHabilidad?: string | undefined;
    elementoMedioPrincipalId?: string | undefined;
    contacto?: Contacto;
    castings?: CastingPersona[] | undefined;
    readonly edad?: number;
    readonly edadString?: string | undefined;
}

export interface PersonaResponsePaginado {
    elementos?: Persona[] | undefined;
    total?: number;
    pagina?: number;
    tamano?: number;
}

export interface PersonasUsuario {
    id?: string | undefined;
    rev?: string | undefined;
    readonly deleted?: boolean;
    readonly conflicts?: string[] | undefined;
    readonly attachments?: CouchAttachment[] | undefined;
    usuarioId?: string | undefined;
    clienteId?: string | undefined;
    agenciaId?: string | undefined;
    idPersonas?: string[] | undefined;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface PropiedadesFisicas {
    mks?: boolean;
    altura?: number;
    peso?: number;
    colorOjosId?: string | undefined;
    colorCabelloId?: string | undefined;
    tipoCabelloId?: string | undefined;
    etniaId?: string | undefined;
    imc?: number;
}

export interface PropiedadesVestuario {
    pantalon?: number;
    playera?: number;
    calzado?: number;
    tipoTallaId?: string | undefined;
}

export interface RegistroUsuario {
    email: string;
    nombre: string;
    clienteId?: string | undefined;
    rol?: TipoRolCliente;
    castingId?: string | undefined;
    agenciaId?: string | undefined;
    mensaje?: string | undefined;
    mensajeDe?: string | undefined;
}

export interface Respuesta {
    ok?: boolean;
    error?: string | undefined;
    httpCode?: HttpCode;
}

export interface RespuestaLogin {
    token?: string | undefined;
    refreshToken?: string | undefined;
    utcExpiration?: Date;
}

export interface SelectorCastingCategoria {
    id?: string | undefined;
    nombre?: string | undefined;
    categorias?: SelectorCategoria[] | undefined;
    participantes?: MapaUsuarioNombre[] | undefined;
    pernisosEcternos?: PermisosCasting;
}

export interface SelectorCategoria {
    id?: string | undefined;
    nombre?: string | undefined;
    modelos?: ModeloCastingReview[] | undefined;
    comentarios?: ComentarioCategoriaModeloCasting[] | undefined;
    votos?: VotoModeloMapeo[] | undefined;
}

export interface SolicitudAcceso {
    usuario: string;
    contrasena: string;
}

export interface SolicitudSoporteUsuario {
    id?: string | undefined;
    rev?: string | undefined;
    readonly deleted?: boolean;
    readonly conflicts?: string[] | undefined;
    readonly attachments?: CouchAttachment[] | undefined;
    usuarioId?: string | undefined;
    tipo?: TipoServicio;
    email?: string | undefined;
    fechaEnvio?: Date;
    fechaLimiteConfirmacion?: Date | undefined;
}

export enum TipoCuerpo {
    Bajo = "Bajo",
    Normal = "Normal",
    Sobrepeso = "Sobrepeso",
    Obeso = "Obeso",
}

export enum TipoMedio {
    Galería = "Galería",
    Documento = "Documento",
}

export enum TipoRelacionPersona {
    Yo = "Yo",
    PadreTutor = "PadreTutor",
    ApoderadoLegal = "ApoderadoLegal",
    Agencia = "Agencia",
}

export enum TipoRolCliente {
    Administrador = "Administrador",
    Staff = "Staff",
    Modelo = "Modelo",
    RevisorExterno = "RevisorExterno",
    Agencia = "Agencia",
    Ninguno = "Ninguno",
}

export enum TipoServicio {
    RecuperacionContrasena = "RecuperacionContrasena",
}

export interface VotoModeloCategoria {
    usuarioId?: string | undefined;
    fecha?: Date;
    nivelLike?: number;
}

export interface VotoModeloMapeo {
    personaId?: string | undefined;
    usuarioId?: string | undefined;
    nivelLike?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}